---
sidebar_position: 3
sidebar_label: Sequencer
---

import {useEffect, useState, useRef, useCallback as call} from 'react'
import {Sequencer} from '../../components/Sequencer'

export const getNotesForOctave = (octave) =>
    Object.keys(Notes).reduce((state, note) => {
        if (note.split('').pop() === String(octave))
            state[note] = Notes[note]
        return state
    }, {})

export const defaultPads = [
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 0]
]

export class Synth {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)()
    }
    playNotes(notes = [], state = {}) {
        const {release, bpm, type, delay} = state;
        if (notes.length <= 0) return
        const oscNode = this.ctx.createOscillator(),
            delayNode = this.ctx.createDelay(),
              vcaNode = this.ctx.createGain();
        oscNode.type = type.toLowerCase();
        oscNode.frequency.value = notes[0];
        delayNode.delayTime.value = delay ? bpm / 2000 : 0;
        vcaNode.gain.value = 1;
        // Connections
        oscNode.connect(vcaNode)
        vcaNode.connect(delayNode)
        vcaNode.connect(this.ctx.destination)
        delayNode.connect(this.ctx.destination)
        // start
        oscNode.start(0)
        setTimeout(() => {
            vcaNode.gain.setTargetAtTime(0, this.ctx.currentTime, 0.015)
        }, release)
    }
}

export const Notes = {
    ["C0"]: 16.35,
    ["C#0"]: 17.32,
    ["D0"]: 18.35,
    ["D#0"]: 19.45,
    ["E0"]: 20.6,
    ["F0"]: 21.83,
    ["F#0"]: 23.12,
    ["G0"]: 24.5,
    ["G#0"]: 25.96,
    ["A0"]: 27.5,
    ["A#0"]: 29.14,
    ["B0"]: 30.87,
    ["C1"]: 32.7,
    ["C#1"]: 34.65,
    ["D1"]: 36.71,
    ["D#1"]: 38.89,
    ["E1"]: 41.2,
    ["F1"]: 43.65,
    ["F#1"]: 46.25,
    ["G1"]: 49,
    ["G#1"]: 51.91,
    ["A1"]: 55,
    ["A#1"]: 58.27,
    ["B1"]: 61.74,
    ["C2"]: 65.41,
    ["C#2"]: 69.3,
    ["D2"]: 73.42,
    ["D#2"]: 77.78,
    ["E2"]: 82.41,
    ["F2"]: 87.31,
    ["F#2"]: 92.5,
    ["G2"]: 98,
    ["G#2"]: 103.83,
    ["A2"]: 110,
    ["A#2"]: 116.54,
    ["B2"]: 123.47,
    ["C3"]: 130.81,
    ["C#3"]: 138.59,
    ["D3"]: 146.83,
    ["D#3"]: 155.56,
    ["E3"]: 164.81,
    ["F3"]: 174.61,
    ["F#3"]: 185,
    ["G3"]: 196,
    ["G#3"]: 207.65,
    ["A3"]: 220,
    ["A#3"]: 233.08,
    ["B3"]: 246.94,
    ["C4"]: 261.63,
    ["C#4"]: 277.18,
    ["D4"]: 293.66,
    ["D#4"]: 311.13,
    ["E4"]: 329.63,
    ["F4"]: 349.23,
    ["F#4"]: 369.99,
    ["G4"]: 392,
    ["G#4"]: 415.3,
    ["A4"]: 440,
    ["A#4"]: 466.16,
    ["B4"]: 493.88,
    ["C5"]: 523.25,
    ["C#5"]: 554.37,
    ["D5"]: 587.33,
    ["D#5"]: 622.25,
    ["E5"]: 659.26,
    ["F5"]: 698.46,
    ["F#5"]: 739.99,
    ["G5"]: 783.99,
    ["G#5"]: 830.61,
    ["A5"]: 880,
    ["A#5"]: 932.33,
    ["B5"]: 987.77,
    ["C6"]: 1046.5,
    ["C#6"]: 1108.73,
    ["D6"]: 1174.66,
    ["D#6"]: 1244.51,
    ["E6"]: 1318.51,
    ["F6"]: 1396.91,
    ["F#6"]: 1479.98,
    ["G6"]: 1567.98,
    ["G#6"]: 1661.22,
    ["A6"]: 1760,
    ["A#6"]: 1864.66,
    ["B6"]: 1975.53,
    ["C7"]: 2093,
    ["C#7"]: 2217.46,
    ["D7"]: 2349.32,
    ["D#7"]: 2489.02,
    ["E7"]: 2637.02,
    ["F7"]: 2793.83,
    ["F#7"]: 2959.96,
    ["G7"]: 3135.96,
    ["G#7"]: 3322.44,
    ["A7"]: 3520,
    ["A#7"]: 3729.31,
    ["B7"]: 3951.07,
    ["C8"]: 4186.01,
    ["C#8"]: 4434.92,
    ["D8"]: 4698.64,
    ["D#8"]: 4978.03
}

export default function () {
    const synth = useRef(null),
        interval = useRef(null),
        [bpm, setBpm] = useState(150),
       [step, setStep] = useState(0),
      [steps,_setSteps] = useState(8),
     [octave, setOctave] = useState(4),
    [release, setRelease] = useState(100),
    [playing, setPlaying] = useState(false),
      [delay, setDelay] = useState(false),
       [type, setTypes] = useState('sine'),
      [notes, setNotes] = useState(getNotesForOctave(4)),
       [pads, setPads] = useState(defaultPads)
    /**
     * play audio
     */
    const play = call(() => {
        synth.current = new Synth()
        const notesArray = Object.keys(notes).map(key => notes[key])
        setPlaying(true)
        interval.current = setInterval(() => {
            setStep(step => {
                const nextStep = step < steps - 1? step + 1 : 0
                const nextPads = pads[nextStep]
                    .map((pad, i) => (pad === 1 ? notesArray[i] : null))
                    .filter(x => x)
                synth.current?.playNotes(nextPads, {release, bpm, type, delay})
                return nextStep
            })
        }, (60 * 1000) / bpm / 2)
    }, [pads, notes, release, bpm, type, delay])
    /**
     * pause audio
     */
    const pause = call(() => {
        setStep(0)
        setPlaying(false)
        clearInterval(interval.current)
    }, [interval.current])
    /**
     * change config
     */
    useEffect(() => {
        pause()
        if (playing) play()
    }, [play, pause, bpm, type, octave, playing, delay, release])
    /**
     * rendering
     */
    return (
      <Sequencer>
        <Sequencer.Buttons>
          <button
            type="button"
            className={playing ? 'active' : ''}
            onClick={() => {
                if (playing) pause()
                else play()
            }}
          >
            {playing? 'Pause': 'Play'}
          </button>
          <Sequencer.SelectWrapper>
            <span>BPM</span>
            <input
              type="number"
              min="80"
              max="300"
              step="1"
              defaultValue={bpm}
              onChange={e => 60 < bpm && bpm < 300 && setBpm(+e.target.value)}
            />
          </Sequencer.SelectWrapper>
          <Sequencer.SelectWrapper>
            <span>Wave</span>
            <select
              value={type}
              data-label="wave"
              className="wave"
              onChange={e => setTypes(e.target.value)}
            >
              <option>Sine</option>
              <option>Square</option>
              <option>Sawtooth</option>
              <option>Triangle</option>
            </select>
          </Sequencer.SelectWrapper>
          <Sequencer.SelectWrapper>
            <span>Octave</span>
            <select
              value={octave}
              data-label="octave"
              className="octave"
              onChange={({target: {value}}) => {
                setOctave(Number(value))
                setNotes(getNotesForOctave(Number(value)))
              }}>
              <option>1</option>
              <option>2</option>
              <option>3</option>
              <option>4</option>
              <option>5</option>
              <option>6</option>
              <option>7</option>
            </select>
          </Sequencer.SelectWrapper>
          <Sequencer.SelectWrapper>
            <span>Release</span>
            <input
              type="number"
              min="0"
              max="400"
              step="1"
              defaultValue={release}
              onChange={e => setRelease(Number(e.target.value))}
            />
          </Sequencer.SelectWrapper>
          <button
            type="button"
            className={delay? 'active': ''}
            onClick={() => setDelay(delay => !delay)}
          >
            Delay
          </button>
        </Sequencer.Buttons>
        <Sequencer.NoteSet>
          {Object.keys(notes)
            .slice(0, 8)
            .reverse()
            .map(note => (
              <li key={`note-${note}`}>
                {note.slice(0, note.length - 1)}
              </li>
            ))}
        </Sequencer.NoteSet>
        <Sequencer.Flex>
          {pads.map((group, j) => (
            <Sequencer.Pads key={`pad-${j}`}>
              {group.map((pad, i) => (
                <Sequencer.Pad
                  key={`pad-group-${i}`}
                  light={pad === 1}
                  active={j === step}
                  onClick={() => {
                    setPads(pads => {
                      const clonedPads = pads.slice(0)
                      const iState = clonedPads[j][i]
                      clonedPads[j] = [0, 0, 0, 0, 0, 0, 0, 0]
                      clonedPads[j][i] = iState === 1 ? 0 : 1
                      return clonedPads
                    })
                  }}
                >
                </Sequencer.Pad>
              ))}
            </Sequencer.Pads>
          ))}
        </Sequencer.Flex>
      </Sequencer>
    )
}
